package mr.ynk.util.string {    public class StringUtil {        public static const ALPHABET:String                 = "abcdefghijklmnopqrstuvwxyz";        public static const NUMBERS:String                  = "1234567890";        public static const EMAIL_REGEX:RegExp              = /^[_\.0-9a-z-]+\@([0-9a-z][0-9a-z-]+\.)+[a-z]{2,4}$/i;        public static const DUTCH_ZIPCODE_REGEX:RegExp      = /^[0-9]{4}[ ]{0,1}[a-zA-Z]{2}$/i;        public static const DUTCH_TELEPHONE_REGEX:RegExp    = /^0[1-9]{1}[0-9]{8}$/i;        public static const EMPTY_REGEX:RegExp              = /^[\s]*$/g;        public static const DUTCH_TELEPHONE_RESTRICT_STRING :String = NUMBERS;        public static const EMAIL_RESTRICT_STRING           :String = "@a-zA-Z0-9_.\-+";        public function StringUtil () {}        /**        * trim        * @param	_str - The string to trim        * @param	_left - optional, whether to trim the left side of the string. Default = true;        * @param	_right - optional, whether to trim the right side of the string. Default = true;        * @return String - the trimmed string        * removes whitespaces from the left and right side of a string        */        static public function trim ( _str:String, _left:Boolean = true, _right:Boolean = true ) :String        {            if ( _left ) _str = _str.replace ( /^(\s| )+/g, '' );            if ( _right ) _str = _str.replace ( /(\s| )+$/g, '' );            return _str;        }        /**         * stripMultipleSpaces         * @param	_str         * @return the stripped string         * removes all multiple spaces in a string         */        static public function stripMultipleSpaces ( _str:String ):String        {            return _str.replace ( /[ ]{2,}/g, ' ' );        }        /**        * isEmpty        * @param	_str        * @return Boolean - true if, after removing all beginning and ending whitespaces, the string is empty        */        static public function isEmpty ( _str:String ) :Boolean        {            return EMPTY_REGEX.test ( _str );        }        /**        * isEmpty        * @param	_str        * @return Boolean - true if, after removing all beginning and ending whitespaces, the string is not empty        */        static public function isNotEmpty ( _str:String ) :Boolean        {            if ( _str == null ) return false;            return !EMPTY_REGEX.test ( _str );        }        /**        * hasOnlyCharacters        * @param	_str - the string to check        * @param	_chars - string containing the characters that this string may have        * @return Boolean - true if only the characters that are provided in _chars are in _str. Returns false if any other character is in _str        */        static public function hasOnlyCharacters ( _str:String, _chars:String, _canBeEmpty:Boolean = true ) :Boolean        {            if ( _chars.length == 0 ) return _canBeEmpty ? /^$/.test ( _str ) : false;            var regStr:String = '/^[';            for ( var i:Number = 0; i < _chars.length; i++ )                regStr += _chars.charAt ( i ) + '|';            regStr += ']' + ( _canBeEmpty ? '*' : '.' ) + '/';            trace ( regStr );            return new RegExp ( regStr, 'mg' ).test ( _str );        }        /**        * hasNotCharacters        * @param	_str - the string to check        * @param	_chars - a string of characters that are not allowed in this string        * @return Boolean - true if the characters that are provided in _chars are not in _str. Returns false if any of the characters in _chars is in _str        */        static public function hasNotCharacters ( _str:String, _chars:String ) :Boolean        {            for ( var i:Number = 0; i < _str.length; i++ ) {                var has:Boolean = false;                var checkChar:Number = 0;                while ( checkChar < _chars.length )                {                    if ( _chars.charAt ( checkChar ) == _str.charAt ( i ) ) return false;                    checkChar++;                }            }            return true;        }        /**        * isEmail        * @param	_str - the string to check        * @return Boolean - true if the provided string could be an email address        */        static public function isEmail ( _str:String ) :Boolean        {            return EMAIL_REGEX.test ( _str );        }        /**        * isZipCode        * @param	_str - the string to check        * @return Boolean - true if the provided string could be a (dutch) zipcode address        */        static public function isDutchZipCode ( _str:String ) :Boolean        {            return DUTCH_ZIPCODE_REGEX.test ( _str );        }        /**        * isDutchTelephone        * @param	_str - the string to check        * @return Boolean - true if the provided string could be a (dutch) zipcode address        */        static public function isDutchTelephone ( _str:String ) :Boolean        {            return DUTCH_TELEPHONE_REGEX.test ( _str );        }        /**        * isNumeric        * @param	_str        * @return Boolean - true if _str contains only numbers        */        static public function isNumeric ( _str:String ) :Boolean        {            return /^\d+$/.test( _str );        }        /**        * isAlphaNumeric        * @param	_str        * @return Boolean - true if _str contains only letters and numbers        */        static public function isAlphaNumeric ( _str:String ) :Boolean        {            return /^[a-z0-9]+$/i.test( _str );        }        /**        * isAlphaNumeric        * @param	_str        * @return Boolean - true if _str contains only letters        */        static public function isAlpha ( _str:String ) :Boolean        {            return /^[a-z]+$/i.test( _str );        }        /**         * does what the function says to _str         * @param	_str         * @return         */        static public function replaceSpacesForUnderScores ( _str:String ) :String        {            return _str.replace ( /[ ]/g, '_' )        }        /**        * stringReplace        * @param	_str - the string to replace stuff in        * @param	_what - what to replace        * @param	_for - replace with this        * @return String - the modified string        */        static public function stringReplace ( _str:String, _what:String, _for :String ) :String        {            return ( _str.split ( _what ).join ( _for ) );        }        /**        * zeroFill - adds zeroes at the beginning of a string        * @param	_str        * @param	_minNumZeros - the minimum length of the string        * @return String - the modified string        */        static public function zeroFill ( _str:String, _minNumZeros:uint ) :String        {            while ( _str.length < _minNumZeros ) _str = '0' + _str;            return _str;        }    }}